// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.6.1
// - protoc             v6.33.4
// source: plugin/external/proto/plugin.proto

package proto

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	PluginService_GetManifest_FullMethodName       = "/workflow.plugin.v1.PluginService/GetManifest"
	PluginService_GetModuleTypes_FullMethodName    = "/workflow.plugin.v1.PluginService/GetModuleTypes"
	PluginService_GetStepTypes_FullMethodName      = "/workflow.plugin.v1.PluginService/GetStepTypes"
	PluginService_GetTriggerTypes_FullMethodName   = "/workflow.plugin.v1.PluginService/GetTriggerTypes"
	PluginService_GetModuleSchemas_FullMethodName  = "/workflow.plugin.v1.PluginService/GetModuleSchemas"
	PluginService_CreateModule_FullMethodName      = "/workflow.plugin.v1.PluginService/CreateModule"
	PluginService_InitModule_FullMethodName        = "/workflow.plugin.v1.PluginService/InitModule"
	PluginService_StartModule_FullMethodName       = "/workflow.plugin.v1.PluginService/StartModule"
	PluginService_StopModule_FullMethodName        = "/workflow.plugin.v1.PluginService/StopModule"
	PluginService_DestroyModule_FullMethodName     = "/workflow.plugin.v1.PluginService/DestroyModule"
	PluginService_CreateStep_FullMethodName        = "/workflow.plugin.v1.PluginService/CreateStep"
	PluginService_ExecuteStep_FullMethodName       = "/workflow.plugin.v1.PluginService/ExecuteStep"
	PluginService_DestroyStep_FullMethodName       = "/workflow.plugin.v1.PluginService/DestroyStep"
	PluginService_InvokeService_FullMethodName     = "/workflow.plugin.v1.PluginService/InvokeService"
	PluginService_DeliverMessage_FullMethodName    = "/workflow.plugin.v1.PluginService/DeliverMessage"
	PluginService_GetConfigFragment_FullMethodName = "/workflow.plugin.v1.PluginService/GetConfigFragment"
)

// PluginServiceClient is the client API for PluginService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// PluginService is implemented by the plugin process and called by the host.
type PluginServiceClient interface {
	// GetManifest returns the plugin's metadata.
	GetManifest(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*Manifest, error)
	// GetModuleTypes returns the module type names this plugin provides.
	GetModuleTypes(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*TypeList, error)
	// GetStepTypes returns the step type names this plugin provides.
	GetStepTypes(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*TypeList, error)
	// GetTriggerTypes returns the trigger type names this plugin provides.
	GetTriggerTypes(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*TypeList, error)
	// GetModuleSchemas returns UI schema definitions for the plugin's module types.
	GetModuleSchemas(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*ModuleSchemaList, error)
	// CreateModule instantiates a module of the given type.
	CreateModule(ctx context.Context, in *CreateModuleRequest, opts ...grpc.CallOption) (*HandleResponse, error)
	// InitModule initializes a previously created module.
	InitModule(ctx context.Context, in *HandleRequest, opts ...grpc.CallOption) (*ErrorResponse, error)
	// StartModule starts a previously initialized module.
	StartModule(ctx context.Context, in *HandleRequest, opts ...grpc.CallOption) (*ErrorResponse, error)
	// StopModule stops a running module.
	StopModule(ctx context.Context, in *HandleRequest, opts ...grpc.CallOption) (*ErrorResponse, error)
	// DestroyModule destroys a module and releases its resources.
	DestroyModule(ctx context.Context, in *HandleRequest, opts ...grpc.CallOption) (*ErrorResponse, error)
	// CreateStep instantiates a pipeline step of the given type.
	CreateStep(ctx context.Context, in *CreateStepRequest, opts ...grpc.CallOption) (*HandleResponse, error)
	// ExecuteStep runs a pipeline step with the given context.
	ExecuteStep(ctx context.Context, in *ExecuteStepRequest, opts ...grpc.CallOption) (*ExecuteStepResponse, error)
	// DestroyStep destroys a step and releases its resources.
	DestroyStep(ctx context.Context, in *HandleRequest, opts ...grpc.CallOption) (*ErrorResponse, error)
	// InvokeService calls a named method on a module's service interface.
	InvokeService(ctx context.Context, in *InvokeServiceRequest, opts ...grpc.CallOption) (*InvokeServiceResponse, error)
	// DeliverMessage delivers a message from the host to a plugin module.
	DeliverMessage(ctx context.Context, in *DeliverMessageRequest, opts ...grpc.CallOption) (*DeliverMessageResponse, error)
	// GetConfigFragment returns YAML config to merge into the host config before module registration.
	GetConfigFragment(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*ConfigFragmentResponse, error)
}

type pluginServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewPluginServiceClient(cc grpc.ClientConnInterface) PluginServiceClient {
	return &pluginServiceClient{cc}
}

func (c *pluginServiceClient) GetManifest(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*Manifest, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Manifest)
	err := c.cc.Invoke(ctx, PluginService_GetManifest_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pluginServiceClient) GetModuleTypes(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*TypeList, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(TypeList)
	err := c.cc.Invoke(ctx, PluginService_GetModuleTypes_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pluginServiceClient) GetStepTypes(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*TypeList, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(TypeList)
	err := c.cc.Invoke(ctx, PluginService_GetStepTypes_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pluginServiceClient) GetTriggerTypes(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*TypeList, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(TypeList)
	err := c.cc.Invoke(ctx, PluginService_GetTriggerTypes_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pluginServiceClient) GetModuleSchemas(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*ModuleSchemaList, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ModuleSchemaList)
	err := c.cc.Invoke(ctx, PluginService_GetModuleSchemas_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pluginServiceClient) CreateModule(ctx context.Context, in *CreateModuleRequest, opts ...grpc.CallOption) (*HandleResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(HandleResponse)
	err := c.cc.Invoke(ctx, PluginService_CreateModule_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pluginServiceClient) InitModule(ctx context.Context, in *HandleRequest, opts ...grpc.CallOption) (*ErrorResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ErrorResponse)
	err := c.cc.Invoke(ctx, PluginService_InitModule_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pluginServiceClient) StartModule(ctx context.Context, in *HandleRequest, opts ...grpc.CallOption) (*ErrorResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ErrorResponse)
	err := c.cc.Invoke(ctx, PluginService_StartModule_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pluginServiceClient) StopModule(ctx context.Context, in *HandleRequest, opts ...grpc.CallOption) (*ErrorResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ErrorResponse)
	err := c.cc.Invoke(ctx, PluginService_StopModule_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pluginServiceClient) DestroyModule(ctx context.Context, in *HandleRequest, opts ...grpc.CallOption) (*ErrorResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ErrorResponse)
	err := c.cc.Invoke(ctx, PluginService_DestroyModule_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pluginServiceClient) CreateStep(ctx context.Context, in *CreateStepRequest, opts ...grpc.CallOption) (*HandleResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(HandleResponse)
	err := c.cc.Invoke(ctx, PluginService_CreateStep_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pluginServiceClient) ExecuteStep(ctx context.Context, in *ExecuteStepRequest, opts ...grpc.CallOption) (*ExecuteStepResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ExecuteStepResponse)
	err := c.cc.Invoke(ctx, PluginService_ExecuteStep_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pluginServiceClient) DestroyStep(ctx context.Context, in *HandleRequest, opts ...grpc.CallOption) (*ErrorResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ErrorResponse)
	err := c.cc.Invoke(ctx, PluginService_DestroyStep_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pluginServiceClient) InvokeService(ctx context.Context, in *InvokeServiceRequest, opts ...grpc.CallOption) (*InvokeServiceResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(InvokeServiceResponse)
	err := c.cc.Invoke(ctx, PluginService_InvokeService_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pluginServiceClient) DeliverMessage(ctx context.Context, in *DeliverMessageRequest, opts ...grpc.CallOption) (*DeliverMessageResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeliverMessageResponse)
	err := c.cc.Invoke(ctx, PluginService_DeliverMessage_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pluginServiceClient) GetConfigFragment(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*ConfigFragmentResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ConfigFragmentResponse)
	err := c.cc.Invoke(ctx, PluginService_GetConfigFragment_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// PluginServiceServer is the server API for PluginService service.
// All implementations must embed UnimplementedPluginServiceServer
// for forward compatibility.
//
// PluginService is implemented by the plugin process and called by the host.
type PluginServiceServer interface {
	// GetManifest returns the plugin's metadata.
	GetManifest(context.Context, *emptypb.Empty) (*Manifest, error)
	// GetModuleTypes returns the module type names this plugin provides.
	GetModuleTypes(context.Context, *emptypb.Empty) (*TypeList, error)
	// GetStepTypes returns the step type names this plugin provides.
	GetStepTypes(context.Context, *emptypb.Empty) (*TypeList, error)
	// GetTriggerTypes returns the trigger type names this plugin provides.
	GetTriggerTypes(context.Context, *emptypb.Empty) (*TypeList, error)
	// GetModuleSchemas returns UI schema definitions for the plugin's module types.
	GetModuleSchemas(context.Context, *emptypb.Empty) (*ModuleSchemaList, error)
	// CreateModule instantiates a module of the given type.
	CreateModule(context.Context, *CreateModuleRequest) (*HandleResponse, error)
	// InitModule initializes a previously created module.
	InitModule(context.Context, *HandleRequest) (*ErrorResponse, error)
	// StartModule starts a previously initialized module.
	StartModule(context.Context, *HandleRequest) (*ErrorResponse, error)
	// StopModule stops a running module.
	StopModule(context.Context, *HandleRequest) (*ErrorResponse, error)
	// DestroyModule destroys a module and releases its resources.
	DestroyModule(context.Context, *HandleRequest) (*ErrorResponse, error)
	// CreateStep instantiates a pipeline step of the given type.
	CreateStep(context.Context, *CreateStepRequest) (*HandleResponse, error)
	// ExecuteStep runs a pipeline step with the given context.
	ExecuteStep(context.Context, *ExecuteStepRequest) (*ExecuteStepResponse, error)
	// DestroyStep destroys a step and releases its resources.
	DestroyStep(context.Context, *HandleRequest) (*ErrorResponse, error)
	// InvokeService calls a named method on a module's service interface.
	InvokeService(context.Context, *InvokeServiceRequest) (*InvokeServiceResponse, error)
	// DeliverMessage delivers a message from the host to a plugin module.
	DeliverMessage(context.Context, *DeliverMessageRequest) (*DeliverMessageResponse, error)
	// GetConfigFragment returns YAML config to merge into the host config before module registration.
	GetConfigFragment(context.Context, *emptypb.Empty) (*ConfigFragmentResponse, error)
	mustEmbedUnimplementedPluginServiceServer()
}

// UnimplementedPluginServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedPluginServiceServer struct{}

func (UnimplementedPluginServiceServer) GetManifest(context.Context, *emptypb.Empty) (*Manifest, error) {
	return nil, status.Error(codes.Unimplemented, "method GetManifest not implemented")
}
func (UnimplementedPluginServiceServer) GetModuleTypes(context.Context, *emptypb.Empty) (*TypeList, error) {
	return nil, status.Error(codes.Unimplemented, "method GetModuleTypes not implemented")
}
func (UnimplementedPluginServiceServer) GetStepTypes(context.Context, *emptypb.Empty) (*TypeList, error) {
	return nil, status.Error(codes.Unimplemented, "method GetStepTypes not implemented")
}
func (UnimplementedPluginServiceServer) GetTriggerTypes(context.Context, *emptypb.Empty) (*TypeList, error) {
	return nil, status.Error(codes.Unimplemented, "method GetTriggerTypes not implemented")
}
func (UnimplementedPluginServiceServer) GetModuleSchemas(context.Context, *emptypb.Empty) (*ModuleSchemaList, error) {
	return nil, status.Error(codes.Unimplemented, "method GetModuleSchemas not implemented")
}
func (UnimplementedPluginServiceServer) CreateModule(context.Context, *CreateModuleRequest) (*HandleResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method CreateModule not implemented")
}
func (UnimplementedPluginServiceServer) InitModule(context.Context, *HandleRequest) (*ErrorResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method InitModule not implemented")
}
func (UnimplementedPluginServiceServer) StartModule(context.Context, *HandleRequest) (*ErrorResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method StartModule not implemented")
}
func (UnimplementedPluginServiceServer) StopModule(context.Context, *HandleRequest) (*ErrorResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method StopModule not implemented")
}
func (UnimplementedPluginServiceServer) DestroyModule(context.Context, *HandleRequest) (*ErrorResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method DestroyModule not implemented")
}
func (UnimplementedPluginServiceServer) CreateStep(context.Context, *CreateStepRequest) (*HandleResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method CreateStep not implemented")
}
func (UnimplementedPluginServiceServer) ExecuteStep(context.Context, *ExecuteStepRequest) (*ExecuteStepResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ExecuteStep not implemented")
}
func (UnimplementedPluginServiceServer) DestroyStep(context.Context, *HandleRequest) (*ErrorResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method DestroyStep not implemented")
}
func (UnimplementedPluginServiceServer) InvokeService(context.Context, *InvokeServiceRequest) (*InvokeServiceResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method InvokeService not implemented")
}
func (UnimplementedPluginServiceServer) DeliverMessage(context.Context, *DeliverMessageRequest) (*DeliverMessageResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method DeliverMessage not implemented")
}
func (UnimplementedPluginServiceServer) GetConfigFragment(context.Context, *emptypb.Empty) (*ConfigFragmentResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetConfigFragment not implemented")
}
func (UnimplementedPluginServiceServer) mustEmbedUnimplementedPluginServiceServer() {}
func (UnimplementedPluginServiceServer) testEmbeddedByValue()                       {}

// UnsafePluginServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to PluginServiceServer will
// result in compilation errors.
type UnsafePluginServiceServer interface {
	mustEmbedUnimplementedPluginServiceServer()
}

func RegisterPluginServiceServer(s grpc.ServiceRegistrar, srv PluginServiceServer) {
	// If the following call panics, it indicates UnimplementedPluginServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&PluginService_ServiceDesc, srv)
}

func _PluginService_GetManifest_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PluginServiceServer).GetManifest(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PluginService_GetManifest_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PluginServiceServer).GetManifest(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _PluginService_GetModuleTypes_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PluginServiceServer).GetModuleTypes(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PluginService_GetModuleTypes_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PluginServiceServer).GetModuleTypes(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _PluginService_GetStepTypes_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PluginServiceServer).GetStepTypes(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PluginService_GetStepTypes_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PluginServiceServer).GetStepTypes(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _PluginService_GetTriggerTypes_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PluginServiceServer).GetTriggerTypes(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PluginService_GetTriggerTypes_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PluginServiceServer).GetTriggerTypes(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _PluginService_GetModuleSchemas_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PluginServiceServer).GetModuleSchemas(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PluginService_GetModuleSchemas_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PluginServiceServer).GetModuleSchemas(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _PluginService_CreateModule_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateModuleRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PluginServiceServer).CreateModule(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PluginService_CreateModule_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PluginServiceServer).CreateModule(ctx, req.(*CreateModuleRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PluginService_InitModule_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HandleRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PluginServiceServer).InitModule(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PluginService_InitModule_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PluginServiceServer).InitModule(ctx, req.(*HandleRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PluginService_StartModule_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HandleRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PluginServiceServer).StartModule(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PluginService_StartModule_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PluginServiceServer).StartModule(ctx, req.(*HandleRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PluginService_StopModule_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HandleRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PluginServiceServer).StopModule(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PluginService_StopModule_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PluginServiceServer).StopModule(ctx, req.(*HandleRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PluginService_DestroyModule_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HandleRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PluginServiceServer).DestroyModule(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PluginService_DestroyModule_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PluginServiceServer).DestroyModule(ctx, req.(*HandleRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PluginService_CreateStep_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateStepRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PluginServiceServer).CreateStep(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PluginService_CreateStep_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PluginServiceServer).CreateStep(ctx, req.(*CreateStepRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PluginService_ExecuteStep_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ExecuteStepRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PluginServiceServer).ExecuteStep(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PluginService_ExecuteStep_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PluginServiceServer).ExecuteStep(ctx, req.(*ExecuteStepRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PluginService_DestroyStep_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HandleRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PluginServiceServer).DestroyStep(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PluginService_DestroyStep_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PluginServiceServer).DestroyStep(ctx, req.(*HandleRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PluginService_InvokeService_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InvokeServiceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PluginServiceServer).InvokeService(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PluginService_InvokeService_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PluginServiceServer).InvokeService(ctx, req.(*InvokeServiceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PluginService_DeliverMessage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeliverMessageRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PluginServiceServer).DeliverMessage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PluginService_DeliverMessage_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PluginServiceServer).DeliverMessage(ctx, req.(*DeliverMessageRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PluginService_GetConfigFragment_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PluginServiceServer).GetConfigFragment(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PluginService_GetConfigFragment_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PluginServiceServer).GetConfigFragment(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

// PluginService_ServiceDesc is the grpc.ServiceDesc for PluginService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var PluginService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "workflow.plugin.v1.PluginService",
	HandlerType: (*PluginServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetManifest",
			Handler:    _PluginService_GetManifest_Handler,
		},
		{
			MethodName: "GetModuleTypes",
			Handler:    _PluginService_GetModuleTypes_Handler,
		},
		{
			MethodName: "GetStepTypes",
			Handler:    _PluginService_GetStepTypes_Handler,
		},
		{
			MethodName: "GetTriggerTypes",
			Handler:    _PluginService_GetTriggerTypes_Handler,
		},
		{
			MethodName: "GetModuleSchemas",
			Handler:    _PluginService_GetModuleSchemas_Handler,
		},
		{
			MethodName: "CreateModule",
			Handler:    _PluginService_CreateModule_Handler,
		},
		{
			MethodName: "InitModule",
			Handler:    _PluginService_InitModule_Handler,
		},
		{
			MethodName: "StartModule",
			Handler:    _PluginService_StartModule_Handler,
		},
		{
			MethodName: "StopModule",
			Handler:    _PluginService_StopModule_Handler,
		},
		{
			MethodName: "DestroyModule",
			Handler:    _PluginService_DestroyModule_Handler,
		},
		{
			MethodName: "CreateStep",
			Handler:    _PluginService_CreateStep_Handler,
		},
		{
			MethodName: "ExecuteStep",
			Handler:    _PluginService_ExecuteStep_Handler,
		},
		{
			MethodName: "DestroyStep",
			Handler:    _PluginService_DestroyStep_Handler,
		},
		{
			MethodName: "InvokeService",
			Handler:    _PluginService_InvokeService_Handler,
		},
		{
			MethodName: "DeliverMessage",
			Handler:    _PluginService_DeliverMessage_Handler,
		},
		{
			MethodName: "GetConfigFragment",
			Handler:    _PluginService_GetConfigFragment_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "plugin/external/proto/plugin.proto",
}

const (
	EngineCallbackService_TriggerWorkflow_FullMethodName = "/workflow.plugin.v1.EngineCallbackService/TriggerWorkflow"
	EngineCallbackService_GetService_FullMethodName      = "/workflow.plugin.v1.EngineCallbackService/GetService"
	EngineCallbackService_Log_FullMethodName             = "/workflow.plugin.v1.EngineCallbackService/Log"
	EngineCallbackService_PublishMessage_FullMethodName  = "/workflow.plugin.v1.EngineCallbackService/PublishMessage"
	EngineCallbackService_Subscribe_FullMethodName       = "/workflow.plugin.v1.EngineCallbackService/Subscribe"
	EngineCallbackService_Unsubscribe_FullMethodName     = "/workflow.plugin.v1.EngineCallbackService/Unsubscribe"
)

// EngineCallbackServiceClient is the client API for EngineCallbackService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// EngineCallbackService is implemented by the host and called by the plugin.
type EngineCallbackServiceClient interface {
	// TriggerWorkflow fires a workflow trigger from the plugin side.
	TriggerWorkflow(ctx context.Context, in *TriggerWorkflowRequest, opts ...grpc.CallOption) (*ErrorResponse, error)
	// GetService checks if a named service exists in the host registry.
	GetService(ctx context.Context, in *GetServiceRequest, opts ...grpc.CallOption) (*GetServiceResponse, error)
	// Log sends a log entry from the plugin to the host logger.
	Log(ctx context.Context, in *LogRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// PublishMessage publishes a message to the host message broker.
	PublishMessage(ctx context.Context, in *PublishMessageRequest, opts ...grpc.CallOption) (*PublishMessageResponse, error)
	// Subscribe registers the plugin to receive messages on a topic.
	Subscribe(ctx context.Context, in *SubscribeRequest, opts ...grpc.CallOption) (*ErrorResponse, error)
	// Unsubscribe removes a plugin's subscription to a topic.
	Unsubscribe(ctx context.Context, in *UnsubscribeRequest, opts ...grpc.CallOption) (*ErrorResponse, error)
}

type engineCallbackServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewEngineCallbackServiceClient(cc grpc.ClientConnInterface) EngineCallbackServiceClient {
	return &engineCallbackServiceClient{cc}
}

func (c *engineCallbackServiceClient) TriggerWorkflow(ctx context.Context, in *TriggerWorkflowRequest, opts ...grpc.CallOption) (*ErrorResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ErrorResponse)
	err := c.cc.Invoke(ctx, EngineCallbackService_TriggerWorkflow_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *engineCallbackServiceClient) GetService(ctx context.Context, in *GetServiceRequest, opts ...grpc.CallOption) (*GetServiceResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetServiceResponse)
	err := c.cc.Invoke(ctx, EngineCallbackService_GetService_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *engineCallbackServiceClient) Log(ctx context.Context, in *LogRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, EngineCallbackService_Log_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *engineCallbackServiceClient) PublishMessage(ctx context.Context, in *PublishMessageRequest, opts ...grpc.CallOption) (*PublishMessageResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(PublishMessageResponse)
	err := c.cc.Invoke(ctx, EngineCallbackService_PublishMessage_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *engineCallbackServiceClient) Subscribe(ctx context.Context, in *SubscribeRequest, opts ...grpc.CallOption) (*ErrorResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ErrorResponse)
	err := c.cc.Invoke(ctx, EngineCallbackService_Subscribe_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *engineCallbackServiceClient) Unsubscribe(ctx context.Context, in *UnsubscribeRequest, opts ...grpc.CallOption) (*ErrorResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ErrorResponse)
	err := c.cc.Invoke(ctx, EngineCallbackService_Unsubscribe_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// EngineCallbackServiceServer is the server API for EngineCallbackService service.
// All implementations must embed UnimplementedEngineCallbackServiceServer
// for forward compatibility.
//
// EngineCallbackService is implemented by the host and called by the plugin.
type EngineCallbackServiceServer interface {
	// TriggerWorkflow fires a workflow trigger from the plugin side.
	TriggerWorkflow(context.Context, *TriggerWorkflowRequest) (*ErrorResponse, error)
	// GetService checks if a named service exists in the host registry.
	GetService(context.Context, *GetServiceRequest) (*GetServiceResponse, error)
	// Log sends a log entry from the plugin to the host logger.
	Log(context.Context, *LogRequest) (*emptypb.Empty, error)
	// PublishMessage publishes a message to the host message broker.
	PublishMessage(context.Context, *PublishMessageRequest) (*PublishMessageResponse, error)
	// Subscribe registers the plugin to receive messages on a topic.
	Subscribe(context.Context, *SubscribeRequest) (*ErrorResponse, error)
	// Unsubscribe removes a plugin's subscription to a topic.
	Unsubscribe(context.Context, *UnsubscribeRequest) (*ErrorResponse, error)
	mustEmbedUnimplementedEngineCallbackServiceServer()
}

// UnimplementedEngineCallbackServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedEngineCallbackServiceServer struct{}

func (UnimplementedEngineCallbackServiceServer) TriggerWorkflow(context.Context, *TriggerWorkflowRequest) (*ErrorResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method TriggerWorkflow not implemented")
}
func (UnimplementedEngineCallbackServiceServer) GetService(context.Context, *GetServiceRequest) (*GetServiceResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetService not implemented")
}
func (UnimplementedEngineCallbackServiceServer) Log(context.Context, *LogRequest) (*emptypb.Empty, error) {
	return nil, status.Error(codes.Unimplemented, "method Log not implemented")
}
func (UnimplementedEngineCallbackServiceServer) PublishMessage(context.Context, *PublishMessageRequest) (*PublishMessageResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method PublishMessage not implemented")
}
func (UnimplementedEngineCallbackServiceServer) Subscribe(context.Context, *SubscribeRequest) (*ErrorResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method Subscribe not implemented")
}
func (UnimplementedEngineCallbackServiceServer) Unsubscribe(context.Context, *UnsubscribeRequest) (*ErrorResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method Unsubscribe not implemented")
}
func (UnimplementedEngineCallbackServiceServer) mustEmbedUnimplementedEngineCallbackServiceServer() {}
func (UnimplementedEngineCallbackServiceServer) testEmbeddedByValue()                               {}

// UnsafeEngineCallbackServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to EngineCallbackServiceServer will
// result in compilation errors.
type UnsafeEngineCallbackServiceServer interface {
	mustEmbedUnimplementedEngineCallbackServiceServer()
}

func RegisterEngineCallbackServiceServer(s grpc.ServiceRegistrar, srv EngineCallbackServiceServer) {
	// If the following call panics, it indicates UnimplementedEngineCallbackServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&EngineCallbackService_ServiceDesc, srv)
}

func _EngineCallbackService_TriggerWorkflow_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TriggerWorkflowRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EngineCallbackServiceServer).TriggerWorkflow(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EngineCallbackService_TriggerWorkflow_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EngineCallbackServiceServer).TriggerWorkflow(ctx, req.(*TriggerWorkflowRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EngineCallbackService_GetService_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetServiceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EngineCallbackServiceServer).GetService(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EngineCallbackService_GetService_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EngineCallbackServiceServer).GetService(ctx, req.(*GetServiceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EngineCallbackService_Log_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LogRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EngineCallbackServiceServer).Log(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EngineCallbackService_Log_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EngineCallbackServiceServer).Log(ctx, req.(*LogRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EngineCallbackService_PublishMessage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PublishMessageRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EngineCallbackServiceServer).PublishMessage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EngineCallbackService_PublishMessage_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EngineCallbackServiceServer).PublishMessage(ctx, req.(*PublishMessageRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EngineCallbackService_Subscribe_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SubscribeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EngineCallbackServiceServer).Subscribe(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EngineCallbackService_Subscribe_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EngineCallbackServiceServer).Subscribe(ctx, req.(*SubscribeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EngineCallbackService_Unsubscribe_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UnsubscribeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EngineCallbackServiceServer).Unsubscribe(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EngineCallbackService_Unsubscribe_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EngineCallbackServiceServer).Unsubscribe(ctx, req.(*UnsubscribeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// EngineCallbackService_ServiceDesc is the grpc.ServiceDesc for EngineCallbackService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var EngineCallbackService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "workflow.plugin.v1.EngineCallbackService",
	HandlerType: (*EngineCallbackServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "TriggerWorkflow",
			Handler:    _EngineCallbackService_TriggerWorkflow_Handler,
		},
		{
			MethodName: "GetService",
			Handler:    _EngineCallbackService_GetService_Handler,
		},
		{
			MethodName: "Log",
			Handler:    _EngineCallbackService_Log_Handler,
		},
		{
			MethodName: "PublishMessage",
			Handler:    _EngineCallbackService_PublishMessage_Handler,
		},
		{
			MethodName: "Subscribe",
			Handler:    _EngineCallbackService_Subscribe_Handler,
		},
		{
			MethodName: "Unsubscribe",
			Handler:    _EngineCallbackService_Unsubscribe_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "plugin/external/proto/plugin.proto",
}
