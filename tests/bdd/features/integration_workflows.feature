Feature: Integration Workflow Testing
  As a workflow developer
  I want to create complex workflows that integrate multiple module types
  So that I can build sophisticated systems combining HTTP, messaging, scheduling, and state machines

  Background:
    Given the workflow UI is running
    And I am logged in as an admin user

  Scenario: Create API-driven data pipeline workflow
    When I create a workflow with:
      | name        | API-Driven Data Pipeline |
      | description | HTTP API that triggers data processing pipeline |
      | config      | modules:\n  - name: api-server\n    type: http.server\n    config:\n      address: ":8080"\n  - name: api-router\n    type: http.router\n  - name: data-ingestion-api\n    type: api.handler\n    config:\n      resourceName: "data"\n  - name: pipeline-broker\n    type: messaging.broker\n  - name: data-validator\n    type: messaging.handler\n  - name: data-transformer\n    type: messaging.handler\n  - name: data-enricher\n    type: messaging.handler\n  - name: data-loader\n    type: messaging.handler\n  - name: batch-scheduler\n    type: scheduler\n    config:\n      cronExpression: "0 */6 * * *"\n  - name: batch-processor\n    type: messaging.handler\n\nworkflows:\n  http:\n    routes:\n      - method: POST\n        path: /api/data/ingest\n        handler: data-ingestion-api\n  messaging:\n    subscriptions:\n      - topic: raw-data\n        handler: data-validator\n      - topic: validated-data\n        handler: data-transformer\n      - topic: transformed-data\n        handler: data-enricher\n      - topic: enriched-data\n        handler: data-loader\n    producers:\n      - name: data-ingestion-api\n        forwardTo: [raw-data]\n      - name: data-validator\n        forwardTo: [validated-data]\n      - name: data-transformer\n        forwardTo: [transformed-data]\n      - name: data-enricher\n        forwardTo: [enriched-data]\n  scheduler:\n    jobs:\n      - scheduler: batch-scheduler\n        job: batch-processor |
    Then the workflow should be created successfully
    And the workflow should use "http.server" module
    And the workflow should use "messaging.broker" module
    And the workflow should use "scheduler" module

  Scenario: Create e-commerce order processing workflow
    When I create a workflow with:
      | name        | E-commerce Order Processing |
      | description | Complete order processing with state management |
      | config      | modules:\n  - name: ecommerce-server\n    type: http.server\n    config:\n      address: ":8081"\n  - name: ecommerce-router\n    type: http.router\n  - name: auth-middleware\n    type: http.middleware.auth\n  - name: orders-api\n    type: api.handler\n    config:\n      resourceName: "orders"\n  - name: order-broker\n    type: messaging.broker\n  - name: payment-processor\n    type: messaging.handler\n  - name: inventory-checker\n    type: messaging.handler\n  - name: fulfillment-handler\n    type: messaging.handler\n  - name: notification-handler\n    type: messaging.handler\n  - name: order-state-machine\n    type: statemachine.engine\n  - name: order-tracker\n    type: state.tracker\n  - name: order-connector\n    type: state.connector\n  - name: daily-reports\n    type: scheduler\n    config:\n      cronExpression: "0 6 * * *"\n  - name: report-generator\n    type: messaging.handler\n\nworkflows:\n  http:\n    routes:\n      - method: POST\n        path: /api/orders\n        handler: orders-api\n        middlewares: [auth-middleware]\n      - method: GET\n        path: /api/orders\n        handler: orders-api\n        middlewares: [auth-middleware]\n      - method: GET\n        path: /api/orders/{id}\n        handler: orders-api\n        middlewares: [auth-middleware]\n  messaging:\n    subscriptions:\n      - topic: order.created\n        handler: inventory-checker\n      - topic: inventory.checked\n        handler: payment-processor\n      - topic: payment.processed\n        handler: fulfillment-handler\n      - topic: order.shipped\n        handler: notification-handler\n    producers:\n      - name: orders-api\n        forwardTo: [order.created]\n      - name: inventory-checker\n        forwardTo: [inventory.checked]\n      - name: payment-processor\n        forwardTo: [payment.processed]\n      - name: fulfillment-handler\n        forwardTo: [order.shipped]\n  statemachine:\n    engine: order-state-machine\n    definitions:\n      - name: order-lifecycle\n        initialState: "created"\n        states:\n          created: {description: "Order created", isFinal: false}\n          inventory_checked: {description: "Inventory verified", isFinal: false}\n          payment_processed: {description: "Payment completed", isFinal: false}\n          shipped: {description: "Order shipped", isFinal: false}\n          delivered: {description: "Order delivered", isFinal: true}\n        transitions:\n          check_inventory: {fromState: "created", toState: "inventory_checked"}\n          process_payment: {fromState: "inventory_checked", toState: "payment_processed"}\n          ship_order: {fromState: "payment_processed", toState: "shipped"}\n          deliver_order: {fromState: "shipped", toState: "delivered"}\n  scheduler:\n    jobs:\n      - scheduler: daily-reports\n        job: report-generator |
    Then the workflow should be created successfully
    And the workflow should manage state transitions
    And the workflow should process messages
    And the workflow should execute on schedule

  Scenario: Create IoT monitoring and alerting workflow
    When I create a workflow with:
      | name        | IoT Monitoring and Alerting |
      | description | IoT device monitoring with real-time alerting |
      | config      | modules:\n  - name: iot-server\n    type: http.server\n    config:\n      address: ":8082"\n  - name: iot-router\n    type: http.router\n  - name: device-api\n    type: api.handler\n    config:\n      resourceName: "devices"\n  - name: metrics-api\n    type: http.handler\n    config:\n      contentType: "application/json"\n  - name: iot-broker\n    type: messaging.broker\n  - name: metrics-processor\n    type: messaging.handler\n  - name: anomaly-detector\n    type: messaging.handler\n  - name: alert-generator\n    type: messaging.handler\n  - name: notification-sender\n    type: messaging.handler\n  - name: device-state-machine\n    type: statemachine.engine\n  - name: device-tracker\n    type: state.tracker\n  - name: metrics-scheduler\n    type: scheduler\n    config:\n      cronExpression: "*/5 * * * *"\n  - name: metrics-aggregator\n    type: messaging.handler\n  - name: alert-scheduler\n    type: scheduler\n    config:\n      cronExpression: "* * * * *"\n  - name: alert-checker\n    type: messaging.handler\n\nworkflows:\n  http:\n    routes:\n      - method: POST\n        path: /api/devices/{id}/metrics\n        handler: metrics-api\n      - method: GET\n        path: /api/devices\n        handler: device-api\n  messaging:\n    subscriptions:\n      - topic: device.metrics\n        handler: metrics-processor\n      - topic: processed.metrics\n        handler: anomaly-detector\n      - topic: anomaly.detected\n        handler: alert-generator\n      - topic: alert.generated\n        handler: notification-sender\n    producers:\n      - name: metrics-api\n        forwardTo: [device.metrics]\n      - name: metrics-processor\n        forwardTo: [processed.metrics]\n      - name: anomaly-detector\n        forwardTo: [anomaly.detected]\n      - name: alert-generator\n        forwardTo: [alert.generated]\n  statemachine:\n    engine: device-state-machine\n    definitions:\n      - name: device-status\n        initialState: "online"\n        states:\n          online: {description: "Device online", isFinal: false}\n          warning: {description: "Device warning", isFinal: false}\n          critical: {description: "Device critical", isFinal: false}\n          offline: {description: "Device offline", isFinal: false}\n        transitions:\n          to_warning: {fromState: "online", toState: "warning"}\n          to_critical: {fromState: "warning", toState: "critical"}\n          to_offline: {fromState: "critical", toState: "offline"}\n          to_online: {fromState: "warning", toState: "online"}\n  scheduler:\n    jobs:\n      - scheduler: metrics-scheduler\n        job: metrics-aggregator\n      - scheduler: alert-scheduler\n        job: alert-checker |
    Then the workflow should be created successfully

  Scenario: Create microservices API gateway workflow
    When I create a workflow with:
      | name        | Microservices API Gateway |
      | description | API gateway with load balancing and circuit breaker |
      | config      | modules:\n  - name: gateway-server\n    type: http.server\n    config:\n      address: ":8083"\n  - name: gateway-router\n    type: http.router\n  - name: auth-middleware\n    type: http.middleware.auth\n  - name: rate-limiter\n    type: http.middleware.ratelimit\n    config:\n      requestsPerMinute: 1000\n  - name: cors-middleware\n    type: http.middleware.cors\n  - name: proxy-handler\n    type: http.proxy\n  - name: gateway-broker\n    type: messaging.broker\n  - name: circuit-breaker\n    type: messaging.handler\n  - name: load-balancer\n    type: messaging.handler\n  - name: metrics-collector\n    type: messaging.handler\n  - name: health-checker\n    type: messaging.handler\n  - name: health-scheduler\n    type: scheduler\n    config:\n      cronExpression: "*/30 * * * * *"\n  - name: metrics-scheduler\n    type: scheduler\n    config:\n      cronExpression: "*/10 * * * * *"\n  - name: service-state-machine\n    type: statemachine.engine\n  - name: service-tracker\n    type: state.tracker\n\nworkflows:\n  http:\n    routes:\n      - method: GET\n        path: /api/users/*\n        handler: proxy-handler\n        middlewares: [auth-middleware, rate-limiter, cors-middleware]\n      - method: POST\n        path: /api/orders/*\n        handler: proxy-handler\n        middlewares: [auth-middleware, rate-limiter]\n      - method: GET\n        path: /api/products/*\n        handler: proxy-handler\n        middlewares: [rate-limiter, cors-middleware]\n  messaging:\n    subscriptions:\n      - topic: gateway.request\n        handler: circuit-breaker\n      - topic: circuit.closed\n        handler: load-balancer\n      - topic: service.response\n        handler: metrics-collector\n    producers:\n      - name: proxy-handler\n        forwardTo: [gateway.request]\n      - name: circuit-breaker\n        forwardTo: [circuit.closed]\n      - name: load-balancer\n        forwardTo: [service.response]\n  statemachine:\n    engine: service-state-machine\n    definitions:\n      - name: service-health\n        initialState: "healthy"\n        states:\n          healthy: {description: "Service healthy", isFinal: false}\n          degraded: {description: "Service degraded", isFinal: false}\n          unhealthy: {description: "Service unhealthy", isFinal: false}\n        transitions:\n          degrade: {fromState: "healthy", toState: "degraded"}\n          fail: {fromState: "degraded", toState: "unhealthy"}\n          recover: {fromState: "degraded", toState: "healthy"}\n  scheduler:\n    jobs:\n      - scheduler: health-scheduler\n        job: health-checker\n      - scheduler: metrics-scheduler\n        job: metrics-collector |
    Then the workflow should be created successfully

  Scenario: Create real-time chat application workflow
    When I create a workflow with:
      | name        | Real-time Chat Application |
      | description | Chat application with user management and message processing |
      | config      | modules:\n  - name: chat-server\n    type: http.server\n    config:\n      address: ":8084"\n  - name: chat-router\n    type: http.router\n  - name: auth-middleware\n    type: http.middleware.auth\n  - name: users-api\n    type: api.handler\n    config:\n      resourceName: "users"\n  - name: messages-api\n    type: api.handler\n    config:\n      resourceName: "messages"\n  - name: chat-broker\n    type: messaging.broker\n  - name: message-processor\n    type: messaging.handler\n  - name: notification-handler\n    type: messaging.handler\n  - name: moderation-handler\n    type: messaging.handler\n  - name: user-state-machine\n    type: statemachine.engine\n  - name: user-tracker\n    type: state.tracker\n  - name: cleanup-scheduler\n    type: scheduler\n    config:\n      cronExpression: "0 2 * * *"\n  - name: cleanup-job\n    type: messaging.handler\n  - name: analytics-scheduler\n    type: scheduler\n    config:\n      cronExpression: "0 * * * *"\n  - name: analytics-job\n    type: messaging.handler\n\nworkflows:\n  http:\n    routes:\n      - method: POST\n        path: /api/users/register\n        handler: users-api\n      - method: POST\n        path: /api/users/login\n        handler: users-api\n      - method: POST\n        path: /api/messages\n        handler: messages-api\n        middlewares: [auth-middleware]\n      - method: GET\n        path: /api/messages\n        handler: messages-api\n        middlewares: [auth-middleware]\n  messaging:\n    subscriptions:\n      - topic: user.registered\n        handler: notification-handler\n      - topic: message.sent\n        handler: message-processor\n      - topic: message.processed\n        handler: moderation-handler\n      - topic: message.approved\n        handler: notification-handler\n    producers:\n      - name: users-api\n        forwardTo: [user.registered]\n      - name: messages-api\n        forwardTo: [message.sent]\n      - name: message-processor\n        forwardTo: [message.processed]\n      - name: moderation-handler\n        forwardTo: [message.approved]\n  statemachine:\n    engine: user-state-machine\n    definitions:\n      - name: user-status\n        initialState: "active"\n        states:\n          active: {description: "User active", isFinal: false}\n          inactive: {description: "User inactive", isFinal: false}\n          banned: {description: "User banned", isFinal: false}\n        transitions:\n          deactivate: {fromState: "active", toState: "inactive"}\n          ban: {fromState: "active", toState: "banned"}\n          reactivate: {fromState: "inactive", toState: "active"}\n  scheduler:\n    jobs:\n      - scheduler: cleanup-scheduler\n        job: cleanup-job\n      - scheduler: analytics-scheduler\n        job: analytics-job |
    Then the workflow should be created successfully

  Scenario: Create monitoring dashboard workflow
    When I create a workflow with:
      | name        | Monitoring Dashboard |
      | description | Real-time monitoring dashboard with alerting |
      | config      | modules:\n  - name: dashboard-server\n    type: http.server\n    config:\n      address: ":8085"\n  - name: dashboard-router\n    type: http.router\n  - name: metrics-api\n    type: api.handler\n    config:\n      resourceName: "metrics"\n  - name: alerts-api\n    type: api.handler\n    config:\n      resourceName: "alerts"\n  - name: monitoring-broker\n    type: messaging.broker\n  - name: metrics-aggregator\n    type: messaging.handler\n  - name: alert-evaluator\n    type: messaging.handler\n  - name: dashboard-updater\n    type: messaging.handler\n  - name: alert-state-machine\n    type: statemachine.engine\n  - name: alert-tracker\n    type: state.tracker\n  - name: metrics-scheduler\n    type: scheduler\n    config:\n      cronExpression: "*/15 * * * * *"\n  - name: aggregation-job\n    type: messaging.handler\n  - name: cleanup-scheduler\n    type: scheduler\n    config:\n      cronExpression: "0 0 * * *"\n  - name: data-cleanup-job\n    type: messaging.handler\n\nworkflows:\n  http:\n    routes:\n      - method: GET\n        path: /api/metrics\n        handler: metrics-api\n      - method: POST\n        path: /api/metrics\n        handler: metrics-api\n      - method: GET\n        path: /api/alerts\n        handler: alerts-api\n      - method: POST\n        path: /api/alerts\n        handler: alerts-api\n  messaging:\n    subscriptions:\n      - topic: metrics.received\n        handler: metrics-aggregator\n      - topic: metrics.aggregated\n        handler: alert-evaluator\n      - topic: alert.triggered\n        handler: dashboard-updater\n    producers:\n      - name: metrics-api\n        forwardTo: [metrics.received]\n      - name: metrics-aggregator\n        forwardTo: [metrics.aggregated]\n      - name: alert-evaluator\n        forwardTo: [alert.triggered]\n  statemachine:\n    engine: alert-state-machine\n    definitions:\n      - name: alert-lifecycle\n        initialState: "monitoring"\n        states:\n          monitoring: {description: "Monitoring state", isFinal: false}\n          warning: {description: "Warning triggered", isFinal: false}\n          critical: {description: "Critical alert", isFinal: false}\n          resolved: {description: "Alert resolved", isFinal: true}\n        transitions:\n          trigger_warning: {fromState: "monitoring", toState: "warning"}\n          escalate: {fromState: "warning", toState: "critical"}\n          resolve: {fromState: "warning", toState: "resolved"}\n          resolve_critical: {fromState: "critical", toState: "resolved"}\n  scheduler:\n    jobs:\n      - scheduler: metrics-scheduler\n        job: aggregation-job\n      - scheduler: cleanup-scheduler\n        job: data-cleanup-job |
    Then the workflow should be created successfully